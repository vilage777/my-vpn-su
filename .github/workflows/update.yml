import requests
import base64
import json
import socket
import re
import time
import os
from urllib.parse import urlparse, unquote
from concurrent.futures import ThreadPoolExecutor

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
# –ò—Å–ø–æ–ª—å–∑—É–µ–º mixed (—Å–º–µ—à–∞–Ω–Ω—ã–π) —Å–ø–∏—Å–æ–∫, –æ–Ω –æ–±—ã—á–Ω–æ –Ω–∞–¥–µ–∂–Ω–µ–µ
SOURCE_URL = "https://raw.githubusercontent.com/MatinGhanbari/v2ray-configs/main/mixed.txt"
OUTPUT_FILE = "sub.txt"
TOP_PER_COUNTRY = 10
MAX_PING = 999  # –£–≤–µ–ª–∏—á–∏–ª –ª–∏–º–∏—Ç –ø–∏–Ω–≥–∞, —á—Ç–æ–±—ã —Ö–æ—Ç—å —á—Ç–æ-—Ç–æ –Ω–∞—à–ª–æ—Å—å
TIMEOUT = 1.5

# –ó–∞–≥–æ–ª–æ–≤–∫–∏, —á—Ç–æ–±—ã –ø—Ä–∏—Ç–≤–æ—Ä–∏—Ç—å—Å—è –±—Ä–∞—É–∑–µ—Ä–æ–º
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
}

def parse_config_info(config):
    try:
        ip, port, name = None, None, ""
        if config.startswith("vmess://"):
            b64 = config[8:]
            missing_padding = len(b64) % 4
            if missing_padding: b64 += '=' * (4 - missing_padding)
            decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
            data = json.loads(decoded)
            ip = data.get("add")
            port = data.get("port")
            name = data.get("ps", "")
        elif config.startswith("vless://") or config.startswith("trojan://") or config.startswith("ss://"):
            parsed = urlparse(config)
            ip = parsed.hostname
            port = parsed.port
            name = unquote(parsed.fragment) if parsed.fragment else ""
        return ip, port, name
    except:
        return None, None, None

def get_country_flag(name):
    flags = re.findall(r'[\U0001F1E6-\U0001F1FF]{2}', name)
    return flags[0] if flags else "üè≥Ô∏è World"

def check_ping(ip, port):
    if not ip or not port: return 9999
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(TIMEOUT)
        start = time.time()
        res = sock.connect_ex((ip, int(port)))
        sock.close()
        if res == 0:
            return int((time.time() - start) * 1000)
    except:
        pass
    return 9999

def process_config(config):
    config = config.strip()
    if not config: return None
    ip, port, name = parse_config_info(config)
    if not ip: return None
    
    latency = check_ping(ip, port)
    if latency < MAX_PING:
        return {
            "config": config,
            "latency": latency,
            "country": get_country_flag(name)
        }
    return None

def main():
    print("üöÄ Starting process...")
    
    # 1. –°–∫–∞—á–∏–≤–∞–Ω–∏–µ
    lines = []
    try:
        resp = requests.get(SOURCE_URL, headers=HEADERS, timeout=20)
        resp.raise_for_status()
        
        content = resp.text
        # –ü—Ä–æ–±—É–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å base64, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
        if "vmess://" not in content and "vless://" not in content:
            try:
                content = base64.b64decode(content).decode('utf-8', errors='ignore')
            except:
                pass
        
        lines = list(set(content.strip().split('\n')))
        print(f"üì• Downloaded {len(lines)} raw configs.")
    except Exception as e:
        print(f"‚ùå Critical Error Downloading: {e}")
        # –ù–µ –≤—ã—Ö–æ–¥–∏–º, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –ø—É—Å—Ç–æ–π —Ñ–∞–π–ª –∏ –Ω–µ –ª–æ–º–∞—Ç—å Git
    
    # –ë–µ—Ä–µ–º –Ω–µ–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ –¥–ª—è —Ç–µ—Å—Ç–∞, –Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    lines = lines[:1000]
    
    # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞
    valid_configs = []
    if lines:
        print(f"üîé Checking {len(lines)} configs (Timeout: {TIMEOUT}s)...")
        with ThreadPoolExecutor(max_workers=50) as executor:
            results = executor.map(process_config, lines)
            for r in results:
                if r: valid_configs.append(r)
    
    print(f"‚úÖ Found {len(valid_configs)} working configs.")

    # 3. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
    if valid_configs:
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
        countries = {}
        for item in valid_configs:
            c = item['country']
            if c not in countries: countries[c] = []
            countries[c].append(item)

        final_list = []
        for c, items in countries.items():
            items.sort(key=lambda x: x['latency'])
            top = items[:TOP_PER_COUNTRY]
            for i in top: final_list.append(i['config'])
            
        result_text = "\n".join(final_list)
        # Base64 –∫–æ–¥–∏—Ä–æ–≤–∫–∞ –¥–ª—è —Ñ–∞–π–ª–∞ –ø–æ–¥–ø–∏—Å–∫–∏
        result_b64 = base64.b64encode(result_text.encode('utf-8')).decode('utf-8')
    else:
        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ - –ø–∏—à–µ–º –∑–∞–≥–ª—É—à–∫—É, —á—Ç–æ–±—ã —Ñ–∞–π–ª —Å–æ–∑–¥–∞–ª—Å—è
        print("‚ö†Ô∏è No working configs found! Writing placeholder.")
        result_b64 = base64.b64encode(b"vmess://ERROR_NO_WORKING_CONFIGS").decode('utf-8')

    # –ó–∞–ø–∏—Å—å —Ñ–∞–π–ª–∞ –í–°–ï–ì–î–ê
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write(result_b64)
    
    print(f"üíæ File {OUTPUT_FILE} created successfully.")

if __name__ == "__main__":
    main()
